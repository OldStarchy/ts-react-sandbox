## Steps taken to set this project up

### Init Git

```bash
git init
git add -A
git commit -m "Initial commit with readme"
```

### Install Dependencies

```bash
yarn init --yes --private
yarn add webpack webpack-cli
yarn add typescript ts-loader
yarn add react @types/react react-dom @types/react-dom
```

Add gitignore for `node_modules`

### Add a test src file and a prettier config

Create `src/main.ts`
Create `.prettierrc`

### Basic configuration of Webpack

Create a webpack config, and tell it to use the `ts-loader` for typescript files.
Typescript also requires a config file, set it up to target "ES5" which is safe relatively for web development.

From now, running `webpack` will build the output `dist/main.js` file.
It may be a good idea to keep the dist files in the repository to prevent the need for a build step during automatic deployments, but for now they'll be ignored.

### Add a basic html page for testing

An empty `index.html` and modify the `ts` to show some output on the page when loaded. Remember to rebuild after changing `main.ts` file.

### Start using React

A few changes here. Generally speaking, the script for a page should be named after the page, so `main.ts` has been renamed to `index.tsx`.
The Webpack config has been updated to allow `tsx` files. It also now provides a name for the entry point which was, confusingly, `main` by deafult. It was coincidental that the typescript file was also called `main.ts`.
The typescript config has also been updated to allow react.

A simple react component has been created called `App`. Its in the `index.tsx` file for now for simplicity, but if it gets larger, it should be moved to its own component.

As you're making changes to the typescript, you can run `webpack -w` to automatically rebuild on save.

### Add webpack dev server

Now we're doing a bit more development, it would be good to get this going.
In order for this to work fully though, we need to move `index.html` into our build process so `webpack-dev-server` can see it.

```bash
yarn add webpack-dev-server html-webpack-plugin
```

`index.html` has been moved into `src` and its script tag has been removed. the `html-webpack-plugin` will automatically add the script tags in for us.

A the html plugin has been added to the webpack configuration.

In addition to adding the dev server, we've also now got some scripts defined in `package.json` to start the server, run build, and run watch.
These can be executed by `yarn dev`, `yarn build`, and `yarn watch`, etc.

### Add the basic structure for our app

Its likely you've got some html already, or you might just find it to build out plain html from your designs before diving into react.

So, now we add the basics required for a simple TODO list with pagination; some html put directly in the `App` component, and some styles added to `index.html`.

Note a caveat with html in react, some keywords are reserved, so a few attributes have changed names, in this case we use `className` instead of `class` and `htmlFor` instead of `for`.

### Breaking it down into components (TodoItem)

Now we've got roughly what we want laid out, we should separate out the different parts of the html into their own components.

For starters, lets move the `.todo-item` to its own component.

Since we're operating in Typescript, we can explicitly declare the **properties** required by our component in the `TodoItemProps` interface.

The `TodoItem` component itself is then defined as a function that takes an instance of `TodoItemProps` and renders some html based on the properties it was given.

You may notice now though, that we can no longer check / uncheck the items. This is because we've now bound the `checked` property of the checkbox to the props passed to each item and react is going to try keep them in sync. We could instead use the `defaultChecked` property of the `<input>`, but instead of doing that, we'll leave it for now, as we're going handle the change events manually later on.

Important: Now that we're going to be importing typescript files, we need to let webpack know how to find them (as imports don't explicitly add the extension). The webpack config has been updated to search for typescript files in addition to javascript ones.

### Breaking it down into components (TodoList, Pagination, and App)

We can also split out the Pagination, and the TodoList itself. As we do this we can have a think about what props each component should have. For example, does the TodoList need to know the ID of every checkbox input? Maybe this can be generated by the checkboxes position in the list.

We'll deal with how the pagination works later on for now too.

### Adding state

So far all good but all we've got is a very static app that does nothing other than display some preset data. To make it interactive, we need to start using **state**.

By now you've seen **props** a bunch of times, and in a few ways state is quite similar. To put it simply, a component is given props to define its properties and its initial state, kind of like constructor arguments. As time goes on, it uses its state to track whats going on (eg. `isLoading` or `currentTab`). It is common for the state of one component to be passed down as props to a sub component.

Up till now all the components we've made have been defined as functions. They take `props` and return some html. To use state, we need to switch to using classes to define the components.

Its definitely worth taking the time to understand what has changed in this step.

`App` has been converted to a class, and now uses a state. It now takes (as props) a `title`, a todo list title `todoList.title` and an initial list of items to fill the list `todoList.initialItems`. Note that in its render function, it doesn't use the `todoList.initialItems` prop any more. Instead it creates a copy of that list in its state and uses that to render its todo list.

### Updating state

Now that we have the list of todo items in the state, we can update them.

To toggle the checkboxes, we need to attach a callback to the input's `onChange` event. Since the state of the items is managed by the TodoList, not by each individual todo item, we can simply expose that `onChange` event to the list component by defining an `onChange` event for the todo item itself, and attach that to the input.

Now, in the todo list, when we render each item, we can create a callback to call our new `toggleItem` method that will update the state.

Its important to know that a component state is immutable, so instead of just updating the individual item property, we rebuild a new state object, deeply cloning the original one, adding the changes we want to make in the process. Keeping the state immutable allows react to be very fast and efficient when determining weather or not a component needs to be re-rendered.

### Show Unchecked Item Count

Just for fun I thought it would be a good idea to show the unchecked item count in the todo list title.

### Pagination

Now we're getting a bit more serious.

As with any application, its up to you to make decisions about how to implement various things in the code. For this example, I've chosen to store the current page in the todo list state. It also would have been fine to store the current page in the Pagination components state too. I chose to put it in the todo list because the `TodoList` component is already a `class` (where `Pagination` is still a `function`) and it felt like it made sense to me to put it there while I was doing it. Its up to you to decide what works best for you and your team.

For starters, instead of manually writing out a bunch of items, I've created a simple item generator that spits out a bunch of randomly named items. Then I added `pageCount` and `onSwitchPage` props to the `Pagination` component to give it the variables it requires to handle stepping forwards and backwards through the pages. Finally I added the logic in the `TodoList` to split the full list of items into page-sized chunks. Since the page size is just a static value I chose to make it a field in the TodoList class, but it could just as easily be passed in as a prop. This would make sense if you wanted the user to be able to pick the page size themselves.

### Ajax

You thought we were serious before...

To help with the example, I've created a dummy `ItemService` with a handful of functions. Each one returns a promise which returns the return value of the function after 1 second. This is an approximation for running a real `fetch` request.

`TodoItem` now takes a `disabled` prop which is passed to the input element, we use this to disable the input while the list is loading. The `onChange` event is also unbound while the input is disabled. This isn't necessary but I thought it was a bit neater than having a change event bound to a disabled item.

The initial list of items passed to `TodoList` has also now been replaced by the `ItemService`, and the functions that manipulated `this.state.items` now call methods on the `ItemService`.

A few state properties have also been added to represent the "loading" state of the list, and individual items.

The first load of items is triggered by the `componentDidMount` event which is called by react once the component is ready to start receiving state changes.

I think its important to see that these functions only manipulate the state, and the render method now does very little processing, it just takes the current state and turns it into some nice html.

### List Keys

I was planning to go through this at some stage but the opportunity didn't present itself.

Whenever you have a list of items in react, its important to make sure each one is given a unique key. The key is used to work out if an item has _changed_ or if it is actually a _different_ item than before. So for the list of `TodoItem`s I've added a `key` prop to the `<li>` and set it to the items index in the list.

The side effect of this is negligible in this case, but what it means is that the first item on every page will reuse the same DOM elements, as will the second, and third, and so on, rather than creating new DOM elements for each item.

This distinction can be a real pain if you're not aware of it, especially when you've got some other things going on with those elements outside of react, like jquery-bound events, or `<input type="file">` elements whose value cannot be changed by scripts. Having react reuse one upload input for another will definitely cause you some headaches, so its important to choose keys carefully and consistently, so that each one can be uniquely identified by it.

### Other Pages

If you looked in `./dist/index.js` up till now you'll see its kinda big as it includes all the dependencies. If you wanted to add a second page + script that also used react, it would make sense to have the common dependencies split into its own file.

In this step I've duplicated `index.tsx` into `other.tsx` and made some tweaks to the titles.

Before we get further in to this, its important to clarify some terms

-   Module: A self contained package of code. This could be a package installed by `yarn` or `npm` but it also includes your own source files that are _imported_ into other files, such as `TodoItem.tsx`
-   Chunk: A group of Modules linked together by the dependency graph. `TodoList.tsx` requires `TodoItem.tsx`, `Pagination.tsx`, and `ItemService.ts` (and the `react` module and all its dependencies). By default, the Chunks will have a 1 to 1 relation with Bundles.
-   Bundle: A final output file, it will consist of one or more Chunks.

Up till now, there has been 1 Bundle, `index.js`, it is defined in the webpack config with the entry `index.tsx`.

Webpack starts (enters) with `index.tsx` and collects all **modules** in the dependency tree to create a **chunk**, that chunk is then transpiled and output to the `index.js` **bundle**.

Now we have two entry points, `index.tsx` and `other.tsx`. What the `splitChunks` optimization does, is once the dependency graphs have been built for each (and two chunks have been created, one for each), it will find the common modules between the two chunks, and move (split) them into a new chunk, which then gets output as the `vendor.js` bundle.

Exactly how it chooses which chunks to split can be configured in the webpack config. One way to do it would be to test if the modules come from the `node_modules` folder.

```javascript
{
	splitChunks: {
		chunks: 'all',
		cacheGroups: {
			vendor: {
				test: /[\\\/]node_modules[\\\/]/,
				priority: -10,
				name: 'vendor',
			},
		},
	},
}
```

However this still duplicates our own code in our source directory, if you look in the two output bundles (`index.js` and `other.js`) you'll see that they both contain the code for all our components and other source files inside `src`. Depending on your project, this may be a good solution, but personally I would rather not have any repeated code.

I've found two good alternatives that will not duplicate our modules in the bundles.

The first is taking _everything that is not an entry_ and putting that in the vendor bundle.

```javascript
{
	splitChunks: {
		chunks: 'all',
		cacheGroups: {
			vendor: {
				test: module => !module.isEntryModule(),
				priority: -10,
				name: 'vendor',
			},
		},
	},
}
```

We're one step closer. No code is repeated and you could stop here. However, I've added a function `foo` that is only used by `other.tsx`. Its not required by `index.tsx` but since its in the vendor bundle, it gets loaded with `index.tsx` even when it's not used.

So the second alternative is to check if the module has been used in more than one place.

```javascript
{
	splitChunks: {
		chunks: 'all',
		cacheGroups: {
			vendor: {
				test: module => module.getChunks().length > 1,
				priority: -10,
				name: 'vendor',
			},
		},
	},
}
```

Note that this test is happening _before_ splitting the existing chunks defined by the entry points, so the module could used in either `index`, `other`, or both `index` and `other`. By splitting off any module used in more than one chunk, the function `foo` (which belongs to only the `other` chunk) stays in the `other` chunk. This way its not included in `vendor` and won't be included on pages where its not used.

There are a number of ways to do splitting of chunks. Perhaps you have 3 or more entry points, your dependencies will become more complicated. For this you could create multiple different `vendor` bundles, or just ignore it. You could create one vendor bundle that includes a bunch of polyfills gets served only to IE, while a slimmer vendor bundle is used for Chrome and FireFox. Its also possible to split chunks that are larger than a particular size. You need to draw a line somewhere on how complex you're willing to go with this.

I think the second alternative above is going to be _good enough_ for most things, even if you have a few entry points, the benefit for creating multiple vendor bundles becomes counter productive.
